#!/usr/bin/env ruby

require "rubygems"
require "optparse"
require File.expand_path('../../lib/syslog_shipper',  __FILE__)
require 'trollop'

def main(args)
  options = Trollop::options do
    version "syslog-shipper 1.0"
    banner <<-EOS
      Usage: #{$0} [options] -s HOST:PORT <path_or_glob> [path_or_glob2] [...]
      If a path begins with '+' each line is sent unmodified to the syslog server.
      Otherwise, this tool will prefix each line read from the file with a syslog
      header.
        
      For example: #{$0} -s somehost:514 +/var/log/messages /var/log/apache2/access.syslog
    EOS

    opt :check_interval, "How frequently, in seconds, to check the glob patterns" \
            "for new files", :default => 5, :short => :i
    opt :exclude, "A pattern to ignore. Wildcard/globs accepted." \
            " Can be specified multiple times", :short => :x, :type => :strings       
    opt :server, "What syslog server to ship to (uses TCP)", :type => :string, :required => true
    opt :verbose, "Verbose mode"
    opt :ca_cert, "Custom certificate used to verify TLS certificates", :type => :string
  end

  Trollop.die "You must supply files to watch" if ARGV.length ==0
  
  host, port = options[:server].split(":")
  port = 514 if port == nil

  exluded_patterns = options[:exclude] ? options[:exclude].map{|glob| pattern_to_regexp(glob)} : []

  SyslogShipper::Client.ca_cert = options[:ca_cert]    

  EventMachine.run do
    Signal.trap("INT") do
      EventMachine.schedule do
        $stderr.puts "Got SIGINT"
        exit 128 + (Signal.list["INT"])
      end
    end

    connection = EventMachine::connect(host, port, SyslogShipper::TlsWrapper)

    args.each do |path|
      if path =~ /\A\+/
        raw = true
        path = path[1..-1]
      else
        raw = false
      end
      EventMachine::FileGlobWatchTail.new(path, SyslogShipper::Client,
                                          interval = options[:check_interval],
                                          exclude = exluded_patterns,
                                          start_pos = -1,
                                          connection = connection,
                                          raw = raw,
                                          verbose = options[:verbose]
                                          )
    end # args.each
  end # EventMachine.run
end # def main

exit(main(ARGV))

private 

def pattern_to_regexp(pattern)
  pattern.gsub!(".", "\\.") # fix literal .
  pattern.gsub!("*", ".+")  # * becomes .+
  pattern.gsub!("?", ".")   # ? becomes .
  return Regexp.new(pattern)
end # def pattern_to_regexp
