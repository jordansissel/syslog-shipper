#!/usr/bin/env ruby -rubygems

require File.expand_path('../../lib/syslog_shipper',  __FILE__)
require 'trollop'
require 'yaml'

def main(args)
  options = Trollop::options do
    version "syslog-shipper 1.0"
    banner <<-EOS
      Usage: #{$0} [options] -s HOST:PORT <path_or_glob> [path_or_glob2] [...]
      If a path begins with '+' each line is sent unmodified to the syslog server.
      Otherwise, this tool will prefix each line read from the file with a syslog
      header.
        
      For example: #{$0} -s somehost:514 +/var/log/messages /var/log/apache2/access.syslog
    EOS

    opt :check_interval, "How frequently, in seconds, to check the glob patterns" \
            "for new files", :default => 5, :short => :i
    opt :exclude, "A pattern to ignore. Wildcard/globs accepted." \
            " Can be specified multiple times", :short => :x, :type => :strings       
    opt :server, "What syslog server to ship to (uses TCP)", :type => :string
    opt :verbose, "Verbose mode"
    opt :ping, "Try to connect and quit immediately after"
    opt :ca_cert, "Custom certificate used to verify TLS certificates (implies --tls)", :type => :string
    opt :skip_peer_check, "When connecting with TLS, do not verify the peer (not recommended, implied --tls)"
    opt :tls, "Connect via tls"
    opt :file, "YAML config file", :type => :string
  end

  files = ARGV

  if options[:file]
    config = Hash[YAML::load(open(options[:file])).map { |k, v| [k.to_sym, v] }]
    options.merge!(config)
    files += config[:files]
  end

  Trollop.die "You must supply files to watch" if files.empty?

  puts options if options[:verbose]
  
  files = ARGV

  if options[:file]
    config = Hash[YAML::load(open(options[:file])).map { |k, v| [k.to_sym, v] }]
    options.merge!(config)
    files += config[:files]
  end

  Trollop.die "You must supply files to watch" if files.empty?

  host, port = options[:server].split(":")
  port = 514 if port == nil
  exluded_patterns = options[:exclude] ? options[:exclude].map{|glob| pattern_to_regexp(glob)} : []

  # debug options
  SyslogShipper::Client.ping = options[:ping]
  SyslogShipper::Client.verbose = options[:verbose]

  # TLS options
  SyslogShipper::Client.ca_cert = options[:ca_cert]    
  SyslogShipper::Client.bypass_peer_check = options[:skip_peer_check]
  
  options[:tls] = true if (options[:tls] || options[:skip_peer_check] || options[:ca_cert])
  SyslogShipper::Client.with_tls = options[:tls]

  puts options if options[:verbose]

  EventMachine.run do
    Signal.trap("INT") do
      EventMachine.schedule do
        $stderr.puts "Got SIGINT"
        exit 128 + (Signal.list["INT"])
      end
    end

    connection = if options[:tls]  
      EventMachine::connect(host, port, SyslogShipper::TlsWrapper) 
    else
      EventMachine::connect(host, port) 
    end

    files.uniq.each do |path|
      if path =~ /\A\+/
        raw = true
        path = path[1..-1]
      else
        raw = false
      end

      EventMachine::FileGlobWatchTail.new(path, SyslogShipper::Client,
                                          interval = options[:check_interval],
                                          exclude = exluded_patterns,
                                          start_pos = -1,
                                          connection = connection,
                                          raw = raw)
    end # args.each
  end # EventMachine.run
end # def main

exit(main(ARGV))

private 

def pattern_to_regexp(pattern)
  pattern.gsub!(".", "\\.") # fix literal .
  pattern.gsub!("*", ".+")  # * becomes .+
  pattern.gsub!("?", ".")   # ? becomes .
  return Regexp.new(pattern)
end # def pattern_to_regexp
